import heapq
from collections import Counter
from collections import namedtuple


class Node(namedtuple("Node", ["left", "right"])):  #
    """класс для ветвей дерева - внутренних узлов; у них есть потомки"""

    def walk(self, code, acc):
        """
        чтобы обойти дерево нам нужно
        пойти в левого потомка, добавив к префиксу 0
        затем пойти в правого потомка, добавив к префиксу 1
        """
        self.left.walk(code, acc + "0")
        self.right.walk(code, acc + "1")


class Leaf(namedtuple("Leaf", ["char"])):
    """класс для листьев дерева, у него нет потомков, но есть значение символа"""

    def walk(self, code, acc):
        """потомков у листа нет, по этому для значения мы запишем построенный код для данного символа
        если строка длиной 1 то acc = "", для этого случая установим значение acc = 0"""
        code[self.char] = acc or "0"


class Haff:
    """Главный класс, в котором происходят все необходимые вычисления"""

    def huffman_encode(self, s):
        """
                :param type: str
                :return: dict
                Функция кодирования строки в коды Хаффмана.
                -инициализируем очередь с приоритетами.
                -постоим очередь с помощью цикла, добавив счетчик, уникальный для всех листьев.
                -очередь будет представлена частотой символа, счетчиком и самим символом.
                -построим очередь с приоритетами.
                -инициализируем значение счетчика длиной очереди.
                -пока в очереди есть хотя бы 2 элемента.
                -вытащим элемент с минимальной частотой - левый узел.
                -вытащим следующий элемент с минимальной частотой - правый узел.
                -поместим в очередь новый элемент, у которого частота равна суме частот вытащенных элементов.
                -добавим новый внутренний узел у которого.
                -потомки left и right соответственно.
                -инкрементируем значение счетчика при добавлении нового элемента дерева.
                -инициализируем словарь кодов символов.
                -если строка пустая, то очередь будет пустая и обходить нечего.
                -в очереди 1 элемент, приоритет которого не важен, а сам элемент - корень дерева.
                -обойдем дерева от корня и заполним словарь для получения кодирования Хаффмана.
                -возвращаем словарь символов и соответствующих им кодов.
                """

        if type(s) != str:
            return ''


        h = []
        for ch, freq in Counter(
                s).items():
            h.append(
                (freq, len(h), Leaf(ch)))
        heapq.heapify(h)
        count = len(h)
        while len(h) > 1:
            freq1, _count1, left = heapq.heappop(h)
            freq2, _count2, right = heapq.heappop(h)

            heapq.heappush(h, (freq1 + freq2, count, Node(left, right)))

            count += 1
        code = {}
        if h:
            [(_freq, _count,
              root)] = h
            root.walk(code, "")
        return code

    def huffman_decode(self, encoded, code):
        """
        :param type: str
        :param type: dict
        :return: str
        Функция декодирования исходной строки по кодам Хаффмана
        -инициализируем массив символов раскодированной строки
        -инициализируем значение закодированного символа
        -обойдем закодированную строку по символам
        -добавим текущий символ к строке закодированного символа
        -постараемся найти закодированный символ в словаре кодов
        -если закодированный символ найден,
        -добавим значение раскодированного символа к массиву раскодированной строки
        -обнулим значение закодированного символа
        -вернем значение раскодированной строки
        """

        sx = []
        enc_ch = ""
        for ch in encoded:
            enc_ch += ch
            for dec_ch in code:
                if code.get(dec_ch) == enc_ch:
                    sx.append(dec_ch)
                    enc_ch = ""
                    break
        return "".join(sx)


